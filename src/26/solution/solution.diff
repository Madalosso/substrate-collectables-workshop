diff --git a/src/lib.rs b/src/lib.rs
index 7e04986..abe1450 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -36,7 +36,6 @@ pub mod pallet {
 		// Using 16 bytes to represent a kitty DNA
 		pub dna: [u8; 16],
 		pub owner: T::AccountId,
-		pub price: Option<BalanceOf<T>>,
 	}
 
 	/// Learn about storage value.
@@ -61,11 +60,7 @@ pub mod pallet {
 	pub enum Event<T: Config> {
 		Created { owner: T::AccountId },
 		Transferred { from: T::AccountId, to: T::AccountId, kitty_id: [u8; 16] },
-		/* TODO: Create a new `Event` called `PriceSet` with fields:
-			- `owner` which is `T::AccountId`.
-			- `kitty_id` which is `[u8; 16]`.
-			- `new_price` which is `Option<BalanceOf<T>>`.
-		*/
+		PriceSet { owner: T::AccountId, kitty_id: [u8; 16], new_price: Option<BalanceOf<T>> },
 	}
 
 	#[pallet::error]
@@ -99,17 +94,15 @@ pub mod pallet {
 			Ok(())
 		}
 
-		/* TODO: Make an callable function called `set_price`:
-			- Inputs to the function are:
-				- `origin` which is `OriginFor<T>`.
-				- `kitty_id` which is `[u8; 16]`.
-				- `new_price` which is `Option<BalanceOf<T>`.
-			- Returns a `DispatchResult`
-			- The internal logic, for now, should be:
-				- Extract the caller `who` with `ensure_signed`.
-				- Call `Self::do_set_price` with the appropriate parameters, propagating the result.
-				- Return `Ok(())`.
-		*/
+		pub fn set_price(
+			origin: OriginFor<T>,
+			kitty_id: [u8; 16],
+			new_price: Option<BalanceOf<T>>,
+		) -> DispatchResult {
+			let who = ensure_signed(origin)?;
+			Self::do_set_price(who, kitty_id, new_price)?;
+			Ok(())
+		}
 	}
 
 	// Learn about internal functions.
@@ -132,7 +125,7 @@ pub mod pallet {
 
 		// Learn about `AccountId`.
 		fn mint(owner: T::AccountId, dna: [u8; 16]) -> DispatchResult {
-			let kitty = Kitty { dna, owner: owner.clone(), price: None };
+			let kitty = Kitty { dna, owner: owner.clone() };
 			// Check if the kitty does not already exist in our storage map
 			ensure!(!Kitties::<T>::contains_key(dna), Error::<T>::DuplicateKitty);
 
@@ -175,15 +168,13 @@ pub mod pallet {
 			Ok(())
 		}
 
-		/* TODO: Make an internal function called `do_set_price`:
-			- Inputs to the function are:
-				- `caller` which is `T::AccountId`.
-				- `kitty_id` which is `[u8; 16]`.
-				- `new_price` which is `Option<BalanceOf<T>`.
-			- Returns a `DispatchResult`.
-			- The internal logic, for now, should be:
-				- `Self::deposit_event` for `Event::<T>::PriceSet` with the appropriate params.
-				- Return `Ok(())`.
-		*/
+		pub fn do_set_price(
+			caller: T::AccountId,
+			kitty_id: [u8; 16],
+			new_price: Option<BalanceOf<T>>,
+		) -> DispatchResult {
+			Self::deposit_event(Event::<T>::PriceSet { owner: caller, kitty_id, new_price });
+			Ok(())
+		}
 	}
 }
